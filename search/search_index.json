{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Robotics Development Extensions for ROS 2 This is a Visual Studio Code Extension that provides debugging support for Robot Operating System 2 (ROS 2) development ROS 2 on Windows, Linux and MacOS. The Robot Operating System is a trademark of Open Robotics. Features Automatic ROS environment configuration. Allows starting, stopping and viewing the ROS core status. Automatically create colcon build and test tasks. Run and Debug ROS Launch Files Resolve dependencies with rosdep shortcut Syntax highlighting for .msg , .urdf and other ROS files. Automatically add the ROS C++ include and Python import paths. Format C++ using the ROS clang-format style. Debug a single ROS node (C++ or Python) by attaching to the process . Debug ROS nodes (C++ or Python) launched from a .launch file . Configure Intellisense Available for Microsoft Visual Studio Code and Anysphere's Cursor. Other Offerings URDF / Xacro Editing Ranch Hand Robotics offers a URDF and Xacro editor , which pairs well with this extension Robot Developer Extensions for ROS 1 For those working with ROS 1, the Robot Developer Extensions for ROS 1 are available to support you Discussions Github Discussions are provided for community driven general guidance, walkthroughs, or support. Sponsor If you find this extension useful, please consider sponsoring Ranch Hand Robotics to help support the development of this extension and other open source projects. Acknowledgements This extension is rebranded and re-released by Ranch Hand Robotics, founded by the maintainer of the ms-iot VSCode ROS Extension with permission from Microsoft. Andrew Short ( @ajshort ), original author James Giller ( @JamesGiller ) PickNikRobotics ( @PickNikRobotics ) for code formatting Microsoft ( @ms-iot ) for curating the ms-iot extension and the many contributors and users over the years.","title":"Home"},{"location":"index.html#robotics-development-extensions-for-ros-2","text":"This is a Visual Studio Code Extension that provides debugging support for Robot Operating System 2 (ROS 2) development ROS 2 on Windows, Linux and MacOS. The Robot Operating System is a trademark of Open Robotics.","title":"Robotics Development Extensions for ROS 2"},{"location":"index.html#features","text":"Automatic ROS environment configuration. Allows starting, stopping and viewing the ROS core status. Automatically create colcon build and test tasks. Run and Debug ROS Launch Files Resolve dependencies with rosdep shortcut Syntax highlighting for .msg , .urdf and other ROS files. Automatically add the ROS C++ include and Python import paths. Format C++ using the ROS clang-format style. Debug a single ROS node (C++ or Python) by attaching to the process . Debug ROS nodes (C++ or Python) launched from a .launch file . Configure Intellisense Available for Microsoft Visual Studio Code and Anysphere's Cursor.","title":"Features"},{"location":"index.html#other-offerings","text":"","title":"Other Offerings"},{"location":"index.html#urdf-xacro-editing","text":"Ranch Hand Robotics offers a URDF and Xacro editor , which pairs well with this extension","title":"URDF / Xacro Editing"},{"location":"index.html#robot-developer-extensions-for-ros-1","text":"For those working with ROS 1, the Robot Developer Extensions for ROS 1 are available to support you","title":"Robot Developer Extensions for ROS 1"},{"location":"index.html#discussions","text":"Github Discussions are provided for community driven general guidance, walkthroughs, or support.","title":"Discussions"},{"location":"index.html#sponsor","text":"If you find this extension useful, please consider sponsoring Ranch Hand Robotics to help support the development of this extension and other open source projects.","title":"Sponsor"},{"location":"index.html#acknowledgements","text":"This extension is rebranded and re-released by Ranch Hand Robotics, founded by the maintainer of the ms-iot VSCode ROS Extension with permission from Microsoft. Andrew Short ( @ajshort ), original author James Giller ( @JamesGiller ) PickNikRobotics ( @PickNikRobotics ) for code formatting Microsoft ( @ms-iot ) for curating the ms-iot extension and the many contributors and users over the years.","title":"Acknowledgements"},{"location":"ModelContextProtocol.html","text":"Model Context Protocol (MCP) Server The Model Context Protocol (MCP) Server is a preview feature of the Robot Developer Extension for ROS 2. It allows Large Language Models (LLMs) to introspect a running ROS 2 system, providing a way to query and interact with the ROS 2 environment programmatically. Model Context Protocol (MCP) is a protocol designed by Anthropic to enable LLMs to understand and interact with complex systems. It provides a structured way for LLMs to query system state, access information about components, and perform actions based on the system's context. NOTE: This feature is in preview and may not be fully stable. It is intended for experimental use and feedback. The extension creates a python virtual environment which resides inside the extension install to run the MCP server, which is separate from the ROS 2 environment. This allows it to run independently of the ROS 2 nodes and provides a clean interface for LLMs to interact with the ROS 2 system. This is experimental code, and may cause issues with your ROS 2 system when launched. Please use with caution and report any issues you encounter. Features Provides a server that can be queried by LLMs to understand the current state of a ROS 2 system. Allows LLMs to access information about nodes, topics, services, and parameters in the ROS 2 environment. Facilitates the development of intelligent applications that can leverage the capabilities of ROS 2 through natural language queries. Enables advanced use cases such as automated debugging, system monitoring, and dynamic configuration of ROS 2 nodes. Getting Started To use the MCP Server for ROS 2, Start the ROS 2 MCP Server using the command palette (CTRL-SHIFT-P) and selecting ROS2: Start MCP Server . The first time you run the MCP Server, the extension will create a Python virtual environment. This process may require a super user password to install the required dependencie. Please open the terminal pane and enter your password in the MCP terminal if prompted. This extension will start the server and make it available for LLMs to connect through a configurable endpoint that defaults to http://localhost:3002/sse . Available Tools Tool Name Category Description get_nodes Node Management Returns a list of running ROS nodes get_node_info Node Management Returns detailed information about a specific ROS node by name list_topics Topic Operations Lists available ROS topics with optional type information get_topic_info Topic Operations Get detailed information about a specific ROS topic echo_topic Topic Operations Echo messages from a topic for monitoring publish_to_topic Topic Operations Publish a message to a specific topic list_services Service Operations Lists available ROS services with optional type information get_service_type Service Operations Get the type of a specific ROS service call_service Service Operations Call a ROS service with specified request parameters list_parameters Parameter Management List all parameters of a specific node get_parameter Parameter Management Get the value of a specific parameter from a node set_parameter Parameter Management Set the value of a parameter for a node list_actions Action Operations Lists available ROS actions with optional type information get_action_info Action Operations Get detailed information about a specific ROS action send_action_goal Action Operations Send a goal to an action server record_bag Bag Operations Record ROS topics to a bag file play_bag Bag Operations Play back a ROS bag file get_bag_info Bag Operations Get information about a bag file list_interfaces Interface Inspection List available ROS interfaces (messages, services, actions) show_interface Interface Inspection Show the definition of a specific interface list_packages Package Management List all available ROS packages package_executables Package Management List executables in a specific ROS package get_package_manifest Package Management Get package manifest (package.xml) information list_launch_files Launch Operations List available launch files in a ROS package launch_file Launch Operations Launch a ROS package with specified launch file get_launch_parameters Launch Operations Get parameters available in a launch file run_package_executable Execution Run a ROS package executable with optional arguments list_lifecycle_nodes Lifecycle Management List nodes with lifecycle support get_lifecycle_state Lifecycle Management Get the current lifecycle state of a node set_lifecycle_transition Lifecycle Management Trigger a lifecycle state transition for a node kill_process Utility Kill a ROS process by process ID run_doctor Diagnostics Run ROS 2 doctor to check system and ROS 2 setup Example Session (Graphical) Example Session (Textual) This is an example of how the MCP Server can be used to introspect a ROS 2 system: I'll help you check the running lifecycle nodes in your ROS 2 system. Let me start by examining what lifecycle nodes are currently running. ROS 2 (MCP Server) Now let me get information about the lifecycle nodes specifically: ROS 2 (MCP Server) Let me get detailed information about the lifecycle node and its current state: ROS 2 (MCP Server) Let me try without the leading slash: ROS 2 (MCP Server) Now let me get the current lifecycle state of the lc_talker node: ROS 2 (MCP Server) Let me also check if there are any other nodes that might be lifecycle nodes by checking the lc_listener: ROS 2 (MCP Server) Let me try to get the lifecycle state of lc_listener as well: ROS 2 (MCP Server) Let me get more details about the lifecycle services available for the lc_talker: ROS 2 (MCP Server) ROS 2 (MCP Server) Based on my analysis of the running lifecycle nodes in your ROS 2 system, here's what I found: Running Lifecycle Nodes lc_talker - Primary Lifecycle Node Current State: unconfigured (ID: 1) Node Type: This is the LifecycleTalker node from your lifecycle_talker.cpp file Purpose: A demonstration lifecycle node that publishes string messages to the /lifecycle_chatter topic Available Lifecycle States The lc_talker node supports the standard ROS 2 lifecycle states: Primary States: unknown (0) unconfigured (1) \u2190 Current state inactive (2) active (3) finalized (4) Transition States: configuring (10) cleaningup (11) shuttingdown (12) activating (13) deactivating (14) errorprocessing (15) Current Available Transitions From the unconfigured state, the node can transition to: configure \u2192 moves to configuring state (then to inactive) shutdown \u2192 moves to shuttingdown state (then to finalized) Node Features The lc_talker node provides these lifecycle-specific services: /lc_talker/change_state - Change the lifecycle state /lc_talker/get_state - Get current state /lc_talker/get_available_states - List all possible states /lc_talker/get_available_transitions - Get valid transitions from current state Topics * Publishers: /lifecycle_chatter (std_msgs/String) - publishes messages when active * System Topics: /lc_talker/transition_event - publishes state transition events Conclusion The included model context protocol server offers a powerful way to introspect and interact with ROS 2 systems. It allows you to query the state of nodes, topics, services, and parameters, enabling advanced use cases such as automated debugging, system monitoring, and dynamic configuration of ROS 2 nodes. We'd love to hear your feedback on this feature and any suggestions for improvements.","title":"Model Context Protocol (MCP) Server"},{"location":"ModelContextProtocol.html#model-context-protocol-mcp-server","text":"The Model Context Protocol (MCP) Server is a preview feature of the Robot Developer Extension for ROS 2. It allows Large Language Models (LLMs) to introspect a running ROS 2 system, providing a way to query and interact with the ROS 2 environment programmatically. Model Context Protocol (MCP) is a protocol designed by Anthropic to enable LLMs to understand and interact with complex systems. It provides a structured way for LLMs to query system state, access information about components, and perform actions based on the system's context. NOTE: This feature is in preview and may not be fully stable. It is intended for experimental use and feedback. The extension creates a python virtual environment which resides inside the extension install to run the MCP server, which is separate from the ROS 2 environment. This allows it to run independently of the ROS 2 nodes and provides a clean interface for LLMs to interact with the ROS 2 system. This is experimental code, and may cause issues with your ROS 2 system when launched. Please use with caution and report any issues you encounter.","title":"Model Context Protocol (MCP) Server"},{"location":"ModelContextProtocol.html#features","text":"Provides a server that can be queried by LLMs to understand the current state of a ROS 2 system. Allows LLMs to access information about nodes, topics, services, and parameters in the ROS 2 environment. Facilitates the development of intelligent applications that can leverage the capabilities of ROS 2 through natural language queries. Enables advanced use cases such as automated debugging, system monitoring, and dynamic configuration of ROS 2 nodes.","title":"Features"},{"location":"ModelContextProtocol.html#getting-started","text":"To use the MCP Server for ROS 2, Start the ROS 2 MCP Server using the command palette (CTRL-SHIFT-P) and selecting ROS2: Start MCP Server . The first time you run the MCP Server, the extension will create a Python virtual environment. This process may require a super user password to install the required dependencie. Please open the terminal pane and enter your password in the MCP terminal if prompted. This extension will start the server and make it available for LLMs to connect through a configurable endpoint that defaults to http://localhost:3002/sse .","title":"Getting Started"},{"location":"ModelContextProtocol.html#available-tools","text":"Tool Name Category Description get_nodes Node Management Returns a list of running ROS nodes get_node_info Node Management Returns detailed information about a specific ROS node by name list_topics Topic Operations Lists available ROS topics with optional type information get_topic_info Topic Operations Get detailed information about a specific ROS topic echo_topic Topic Operations Echo messages from a topic for monitoring publish_to_topic Topic Operations Publish a message to a specific topic list_services Service Operations Lists available ROS services with optional type information get_service_type Service Operations Get the type of a specific ROS service call_service Service Operations Call a ROS service with specified request parameters list_parameters Parameter Management List all parameters of a specific node get_parameter Parameter Management Get the value of a specific parameter from a node set_parameter Parameter Management Set the value of a parameter for a node list_actions Action Operations Lists available ROS actions with optional type information get_action_info Action Operations Get detailed information about a specific ROS action send_action_goal Action Operations Send a goal to an action server record_bag Bag Operations Record ROS topics to a bag file play_bag Bag Operations Play back a ROS bag file get_bag_info Bag Operations Get information about a bag file list_interfaces Interface Inspection List available ROS interfaces (messages, services, actions) show_interface Interface Inspection Show the definition of a specific interface list_packages Package Management List all available ROS packages package_executables Package Management List executables in a specific ROS package get_package_manifest Package Management Get package manifest (package.xml) information list_launch_files Launch Operations List available launch files in a ROS package launch_file Launch Operations Launch a ROS package with specified launch file get_launch_parameters Launch Operations Get parameters available in a launch file run_package_executable Execution Run a ROS package executable with optional arguments list_lifecycle_nodes Lifecycle Management List nodes with lifecycle support get_lifecycle_state Lifecycle Management Get the current lifecycle state of a node set_lifecycle_transition Lifecycle Management Trigger a lifecycle state transition for a node kill_process Utility Kill a ROS process by process ID run_doctor Diagnostics Run ROS 2 doctor to check system and ROS 2 setup","title":"Available Tools"},{"location":"ModelContextProtocol.html#example-session-graphical","text":"","title":"Example Session (Graphical)"},{"location":"ModelContextProtocol.html#example-session-textual","text":"This is an example of how the MCP Server can be used to introspect a ROS 2 system: I'll help you check the running lifecycle nodes in your ROS 2 system. Let me start by examining what lifecycle nodes are currently running. ROS 2 (MCP Server) Now let me get information about the lifecycle nodes specifically: ROS 2 (MCP Server) Let me get detailed information about the lifecycle node and its current state: ROS 2 (MCP Server) Let me try without the leading slash: ROS 2 (MCP Server) Now let me get the current lifecycle state of the lc_talker node: ROS 2 (MCP Server) Let me also check if there are any other nodes that might be lifecycle nodes by checking the lc_listener: ROS 2 (MCP Server) Let me try to get the lifecycle state of lc_listener as well: ROS 2 (MCP Server) Let me get more details about the lifecycle services available for the lc_talker: ROS 2 (MCP Server) ROS 2 (MCP Server) Based on my analysis of the running lifecycle nodes in your ROS 2 system, here's what I found: Running Lifecycle Nodes lc_talker - Primary Lifecycle Node Current State: unconfigured (ID: 1) Node Type: This is the LifecycleTalker node from your lifecycle_talker.cpp file Purpose: A demonstration lifecycle node that publishes string messages to the /lifecycle_chatter topic Available Lifecycle States The lc_talker node supports the standard ROS 2 lifecycle states: Primary States: unknown (0) unconfigured (1) \u2190 Current state inactive (2) active (3) finalized (4) Transition States: configuring (10) cleaningup (11) shuttingdown (12) activating (13) deactivating (14) errorprocessing (15) Current Available Transitions From the unconfigured state, the node can transition to: configure \u2192 moves to configuring state (then to inactive) shutdown \u2192 moves to shuttingdown state (then to finalized) Node Features The lc_talker node provides these lifecycle-specific services: /lc_talker/change_state - Change the lifecycle state /lc_talker/get_state - Get current state /lc_talker/get_available_states - List all possible states /lc_talker/get_available_transitions - Get valid transitions from current state Topics * Publishers: /lifecycle_chatter (std_msgs/String) - publishes messages when active * System Topics: /lc_talker/transition_event - publishes state transition events","title":"Example Session (Textual)"},{"location":"ModelContextProtocol.html#conclusion","text":"The included model context protocol server offers a powerful way to introspect and interact with ROS 2 systems. It allows you to query the state of nodes, topics, services, and parameters, enabling advanced use cases such as automated debugging, system monitoring, and dynamic configuration of ROS 2 nodes. We'd love to hear your feedback on this feature and any suggestions for improvements.","title":"Conclusion"},{"location":"configuration.html","text":"ROS Launch Configuration options The ROS Launch configuration block supports the following configuration: Option Description name The name which will be displayed in the VS Code UI launch configuration request launch or attach for launching a ROS launch file, or attaching using the attach UI for Pyton or C++ target the launch file path type must be ros to indicate to VS Code that this is a ROS launch configuration arguments Arguments passed to roslaunch such as map:=/foo.yaml' symbolSearchPath A semicolon delimited search path for Windows symbols, including ROS for Windows symbols downloaded from https://ros-win.visualstudio.com/ros-win/_build additionalSOLibSearchPath A semicolon delimited search path for Linux symbols sourceFileMap A mapping of Source files from where Symbols expect and the location you have on disk. launch If specified, a list of executables to just launch, attaching to everything else. e.g. \"launch\": [\"rviz\", \"gz\"] which prevents attaching a debugger to rviz and gazebo. NOTE: the debugger will ignore file extension: x.py is the same as x.exe. attachDebugger If specified, a list of executables to debug. \"attachDebugger\": [\"my_ros_node\"] will only attach to my_ros_node.exe, my_ros_node.py or my_ros_node. Workspace and Global Settings The ROS extension supports the following global settings, which can be overridden in the workspace. Json Option Setting Name Description ros.distro ROS installation distro to be sourced The Distribution to be sourced. On linux, this cause the extension to look for the ROS setup script in /opt/ros/{distro}/setup.bash . On Windows, c:\\opt\\ros\\{distro}\\setup.bat ros.rosSetupScript ROS workspace setup script. Overrides ros.distro. If specified, this will cause the extension to source this script before generating the launch debugging or ROS terminal environment. This overrides the ros.distro, and can be used to specify user scripts or ROS installs in a different location. ros.isolateEnvironment Specify if the extension should not capture the environment VS Code is running in to pass to child processes. Off by default, This setting will prevent the ROS extension from capturing it's hosting environment in case this would conflict with the ROS environment. Workspace example: \u2514\u2500\u2500 .vscode \u251c\u2500\u2500 launch.json \u251c\u2500\u2500 settings.json \u2514\u2500\u2500 tasks.json settings.json { \"ros.distro\" : \"foxy\" , \"ros.rosSetupScript\" : \"/opt/ros/foxy/install/setup.bash\" , \"ros.isolateEnvironment\" : \"false\" }","title":"Configuration"},{"location":"configuration.html#ros-launch-configuration-options","text":"The ROS Launch configuration block supports the following configuration: Option Description name The name which will be displayed in the VS Code UI launch configuration request launch or attach for launching a ROS launch file, or attaching using the attach UI for Pyton or C++ target the launch file path type must be ros to indicate to VS Code that this is a ROS launch configuration arguments Arguments passed to roslaunch such as map:=/foo.yaml' symbolSearchPath A semicolon delimited search path for Windows symbols, including ROS for Windows symbols downloaded from https://ros-win.visualstudio.com/ros-win/_build additionalSOLibSearchPath A semicolon delimited search path for Linux symbols sourceFileMap A mapping of Source files from where Symbols expect and the location you have on disk. launch If specified, a list of executables to just launch, attaching to everything else. e.g. \"launch\": [\"rviz\", \"gz\"] which prevents attaching a debugger to rviz and gazebo. NOTE: the debugger will ignore file extension: x.py is the same as x.exe. attachDebugger If specified, a list of executables to debug. \"attachDebugger\": [\"my_ros_node\"] will only attach to my_ros_node.exe, my_ros_node.py or my_ros_node.","title":"ROS Launch Configuration options"},{"location":"configuration.html#workspace-and-global-settings","text":"The ROS extension supports the following global settings, which can be overridden in the workspace. Json Option Setting Name Description ros.distro ROS installation distro to be sourced The Distribution to be sourced. On linux, this cause the extension to look for the ROS setup script in /opt/ros/{distro}/setup.bash . On Windows, c:\\opt\\ros\\{distro}\\setup.bat ros.rosSetupScript ROS workspace setup script. Overrides ros.distro. If specified, this will cause the extension to source this script before generating the launch debugging or ROS terminal environment. This overrides the ros.distro, and can be used to specify user scripts or ROS installs in a different location. ros.isolateEnvironment Specify if the extension should not capture the environment VS Code is running in to pass to child processes. Off by default, This setting will prevent the ROS extension from capturing it's hosting environment in case this would conflict with the ROS environment. Workspace example: \u2514\u2500\u2500 .vscode \u251c\u2500\u2500 launch.json \u251c\u2500\u2500 settings.json \u2514\u2500\u2500 tasks.json settings.json { \"ros.distro\" : \"foxy\" , \"ros.rosSetupScript\" : \"/opt/ros/foxy/install/setup.bash\" , \"ros.isolateEnvironment\" : \"false\" }","title":"Workspace and Global Settings"},{"location":"debug-support.html","text":"Debug ROS Nodes One of the key goals of this extension is to provide a streamlined debugging experience for ROS nodes. To achieve this, this extension aims to help developers utilize the debugging capabilities provided by Visual Studio Code. This document covers instructions of how to use such functionalities. Attach This extension enables a bootstrapped debugging experience for debugging a ROS (Python or C++) node by attaching to the process. To get started, create a ros -type debug configuration with an attach request: (use Ctrl - Space to bring up the autocomplete dropdown) Attaching to a Python node Attaching to a C++ node Launch This extension enables a streamlined debugging experience for debugging a ROS (Python or C++) node in a ROS launch file similar to a native debug flow. To get started, create a ros -type debug configuration with a launch request: Launch and debug Python and C++ nodes Note Debugging functionality provided by this extension has dependencies on VS Code\u2019s C++ and Python extensions, and those have dependencies on the version of VS Code. To ensure everything works as expected, please make sure to have everything up-to-date. To debug a C++ executable, please make sure the binary is built with debug symbols (e.g. -DCMAKE_BUILD_TYPE=RelWithDebInfo , read more about CMAKE_BUILD_TYPE here ). To use VS Code's C++ extension with MSVC on Windows, please make sure the VS Code instance is launched from a Visual Studio command prompt.","title":"Debug ROS Nodes"},{"location":"debug-support.html#debug-ros-nodes","text":"One of the key goals of this extension is to provide a streamlined debugging experience for ROS nodes. To achieve this, this extension aims to help developers utilize the debugging capabilities provided by Visual Studio Code. This document covers instructions of how to use such functionalities.","title":"Debug ROS Nodes"},{"location":"debug-support.html#attach","text":"This extension enables a bootstrapped debugging experience for debugging a ROS (Python or C++) node by attaching to the process. To get started, create a ros -type debug configuration with an attach request: (use Ctrl - Space to bring up the autocomplete dropdown)","title":"Attach"},{"location":"debug-support.html#attaching-to-a-python-node","text":"","title":"Attaching to a Python node"},{"location":"debug-support.html#attaching-to-a-c-node","text":"","title":"Attaching to a C++ node"},{"location":"debug-support.html#launch","text":"This extension enables a streamlined debugging experience for debugging a ROS (Python or C++) node in a ROS launch file similar to a native debug flow. To get started, create a ros -type debug configuration with a launch request:","title":"Launch"},{"location":"debug-support.html#launch-and-debug-python-and-c-nodes","text":"","title":"Launch and debug Python and C++ nodes"},{"location":"debug-support.html#note","text":"Debugging functionality provided by this extension has dependencies on VS Code\u2019s C++ and Python extensions, and those have dependencies on the version of VS Code. To ensure everything works as expected, please make sure to have everything up-to-date. To debug a C++ executable, please make sure the binary is built with debug symbols (e.g. -DCMAKE_BUILD_TYPE=RelWithDebInfo , read more about CMAKE_BUILD_TYPE here ). To use VS Code's C++ extension with MSVC on Windows, please make sure the VS Code instance is launched from a Visual Studio command prompt.","title":"Note"},{"location":"launchdebugging.html","text":"Launch Debugging Launch Debugging The Visual Studio Code extension for ROS supports launch debugging for ROS 2 nodes, written in Python and C++. The ROS node or nodes to be debugged must be placed in a ROS launch file with the extension .xml or .py . Automatic creation of a launch.json with ROS Launch support .vscode/launch.json is a file which defines a debug launch configuration within VS Code. To create a .vscode/launch.json with ROS debugging support C++ or Python file is selected, vscode uses the selected file to seed the launch creation UI. Click the Run and Debug tab on the left sidebar Select the link to create a .vscode/launch.json file. VS Code will drop down from the command pallet with a list of options, which includes 'ROS'. Select this option. In the next dialog, type the name of the ROS package containing a launch file you'd like to debug. Then find the launch file. Once this is created, you can use the play button in the title bar, or the \"start debugging\" accelerator key, or from the command palle (CTRL-SHIFT-P), select Debug: Start Debugging . NOTE: Other VS Code extensions may interfere with the selection list. If you do not see ROS in the first drop down list, you'll need to create a new file called .vscode/launch.json , then use the manual option described below. Other Notes: * Create a new ROS launch file with just the nodes you'd like to debug, and a separate ROS launch file with all other ROS nodes. * Debugging a launch file with Gazebo or rviz is not supported as this time. Please split these out into separate launch files. * ros2 run is not supported. * Traditional XML launch files are supported for ROS1, and both python and XML based launch files are supported for ROS2. Manually adding a launch file to an existing launch.json If you have an existing launch.json file (or if there is an extension conflict as mentioned above), you can manually add a launch configuration by adding a new block like this. { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS2: Launch my file\" , \"request\" : \"launch\" , \"target\" : \"<full path to your launch.py or launch file>\" , \"launch\" : [ \"rviz\" , \"gz\" ], \"type\" : \"ros2\" } ] } Be sure to include the full path to your launch file, including file extension.","title":"Launchdebugging"},{"location":"launchdebugging.html#launch-debugging","text":"","title":"Launch Debugging"},{"location":"launchdebugging.html#launch-debugging_1","text":"The Visual Studio Code extension for ROS supports launch debugging for ROS 2 nodes, written in Python and C++. The ROS node or nodes to be debugged must be placed in a ROS launch file with the extension .xml or .py .","title":"Launch Debugging"},{"location":"launchdebugging.html#automatic-creation-of-a-launchjson-with-ros-launch-support","text":".vscode/launch.json is a file which defines a debug launch configuration within VS Code. To create a .vscode/launch.json with ROS debugging support C++ or Python file is selected, vscode uses the selected file to seed the launch creation UI. Click the Run and Debug tab on the left sidebar Select the link to create a .vscode/launch.json file. VS Code will drop down from the command pallet with a list of options, which includes 'ROS'. Select this option. In the next dialog, type the name of the ROS package containing a launch file you'd like to debug. Then find the launch file. Once this is created, you can use the play button in the title bar, or the \"start debugging\" accelerator key, or from the command palle (CTRL-SHIFT-P), select Debug: Start Debugging . NOTE: Other VS Code extensions may interfere with the selection list. If you do not see ROS in the first drop down list, you'll need to create a new file called .vscode/launch.json , then use the manual option described below. Other Notes: * Create a new ROS launch file with just the nodes you'd like to debug, and a separate ROS launch file with all other ROS nodes. * Debugging a launch file with Gazebo or rviz is not supported as this time. Please split these out into separate launch files. * ros2 run is not supported. * Traditional XML launch files are supported for ROS1, and both python and XML based launch files are supported for ROS2.","title":"Automatic creation of a launch.json with ROS Launch support"},{"location":"launchdebugging.html#manually-adding-a-launch-file-to-an-existing-launchjson","text":"If you have an existing launch.json file (or if there is an extension conflict as mentioned above), you can manually add a launch configuration by adding a new block like this. { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS2: Launch my file\" , \"request\" : \"launch\" , \"target\" : \"<full path to your launch.py or launch file>\" , \"launch\" : [ \"rviz\" , \"gz\" ], \"type\" : \"ros2\" } ] } Be sure to include the full path to your launch file, including file extension.","title":"Manually adding a launch file to an existing launch.json"},{"location":"openvsx.html","text":"Available on Open-VSX.org This extension is published on https://open-vsx.org/ , making it easy to install and update from Cursor . Compatibility The extension is specifically tested on Cursor to ensure the fullest compatibility and a seamless experience. All features available in Visual Studio Code are supported when using Cursor. NOTE: Due to tight coupling with debuggers, this extension depends specifically on vadimcn.vscode-lldb . Installation To install the extension from OpenVSX, search for it from the Open-VSX marketplace or visit the RDE ROS 2 listing . Feedback If you encounter any issues using this extension, please open an issue in the repository.","title":"Available on Open-VSX.org"},{"location":"openvsx.html#available-on-open-vsxorg","text":"This extension is published on https://open-vsx.org/ , making it easy to install and update from Cursor .","title":"Available on Open-VSX.org"},{"location":"openvsx.html#compatibility","text":"The extension is specifically tested on Cursor to ensure the fullest compatibility and a seamless experience. All features available in Visual Studio Code are supported when using Cursor. NOTE: Due to tight coupling with debuggers, this extension depends specifically on vadimcn.vscode-lldb .","title":"Compatibility"},{"location":"openvsx.html#installation","text":"To install the extension from OpenVSX, search for it from the Open-VSX marketplace or visit the RDE ROS 2 listing .","title":"Installation"},{"location":"openvsx.html#feedback","text":"If you encounter any issues using this extension, please open an issue in the repository.","title":"Feedback"},{"location":"pixi.html","text":"Pixi for ROS 2 Pixi by prefix.dev is a next generation package manager, which includes support for ROS 2 development environments. It provides a cross-platform way to manage ROS 2 workspaces, dependencies, and tools. Open Robotics has standardized on Pixi for Windows development. RoboStack & Open Robotics Open Robotics has partnered with RoboStack to provide a Pixi-based ROS 2 development environment. This environment is designed to work seamlessly with the Robot Developer Extensions for ROS 2, providing a consistent and easy-to-use development experience across platforms. Open Robotics provides an official distribution of core ROS Components through Open Robotics build system. This distribution is recommended for production use cases. RoboStack provides a community-driven distribution of ROS 2 packages, which includes additional packages not available in the Open Robotics distribution. This distribution is recommended for development and testing purposes. Getting Started with Pixi, ROS 2, and the Robot Developer Extensions Install Pixi : Follow the instructions on the Pixi website to install Pixi on your system. Install Visual Studio : Download and install Visual Studio . This is needed for building ROS 2 packages on Windows. Install Visual Studio Code : Download and install Visual Studio Code . Install ROS 2 through RoboStack or Open Robotics depending on your use case: For Development and Testing, follow the instructions on the RoboStack website . For Production Environments, follow the instructions on the ros.org . Install the Robot Developer Extensions (RDE) for ROS 2 : Install the Robot Developer Extensions for ROS 2 from the Visual Studio Code Marketplace or Open-Vsx.org . Configure Pixi in RDE Open the Workspace settings. Set the ROS2.usePixiOnAllPlatforms setting to true if you want to use Pixi on all platforms. This will allow the extension to automatically configure the ROS 2 environment using Pixi. Set the ROS2.rosSetupScript setting to the path of your ROS 2 setup script. If you are using Pixi, this will typically be c:\\pixi_ws\\ros2-windows\\local_setup.bat on Windows or /opt/pixi/ros2-linux/local_setup.bash on Linux. Open a ROS 2 Workspace : Open a folder containing a ROS 2 workspace. The Robot Developer Extensions will automatically detect the ROS 2 environment and configure the workspace accordingly. Troubleshooting If you encounter issues with Pixi or the Robot Developer Extensions, consider the following: - Ensure that Pixi is installed correctly and the pixi command is available in your terminal. - Check the Visual Studio Code output panel for any error messages related to the Robot Developer Extensions. - If you are using RoboStack, ensure that the ROS 2 packages are installed correctly and the environment is set up properly outside of the extension. - For issues related to Pixi, refer to the Pixi documentation or the Pixi Discord server for community support.","title":"Pixi for ROS 2"},{"location":"pixi.html#pixi-for-ros-2","text":"Pixi by prefix.dev is a next generation package manager, which includes support for ROS 2 development environments. It provides a cross-platform way to manage ROS 2 workspaces, dependencies, and tools. Open Robotics has standardized on Pixi for Windows development.","title":"Pixi for ROS 2"},{"location":"pixi.html#robostack-open-robotics","text":"Open Robotics has partnered with RoboStack to provide a Pixi-based ROS 2 development environment. This environment is designed to work seamlessly with the Robot Developer Extensions for ROS 2, providing a consistent and easy-to-use development experience across platforms. Open Robotics provides an official distribution of core ROS Components through Open Robotics build system. This distribution is recommended for production use cases. RoboStack provides a community-driven distribution of ROS 2 packages, which includes additional packages not available in the Open Robotics distribution. This distribution is recommended for development and testing purposes.","title":"RoboStack &amp; Open Robotics"},{"location":"pixi.html#getting-started-with-pixi-ros-2-and-the-robot-developer-extensions","text":"Install Pixi : Follow the instructions on the Pixi website to install Pixi on your system. Install Visual Studio : Download and install Visual Studio . This is needed for building ROS 2 packages on Windows. Install Visual Studio Code : Download and install Visual Studio Code . Install ROS 2 through RoboStack or Open Robotics depending on your use case: For Development and Testing, follow the instructions on the RoboStack website . For Production Environments, follow the instructions on the ros.org . Install the Robot Developer Extensions (RDE) for ROS 2 : Install the Robot Developer Extensions for ROS 2 from the Visual Studio Code Marketplace or Open-Vsx.org . Configure Pixi in RDE Open the Workspace settings. Set the ROS2.usePixiOnAllPlatforms setting to true if you want to use Pixi on all platforms. This will allow the extension to automatically configure the ROS 2 environment using Pixi. Set the ROS2.rosSetupScript setting to the path of your ROS 2 setup script. If you are using Pixi, this will typically be c:\\pixi_ws\\ros2-windows\\local_setup.bat on Windows or /opt/pixi/ros2-linux/local_setup.bash on Linux. Open a ROS 2 Workspace : Open a folder containing a ROS 2 workspace. The Robot Developer Extensions will automatically detect the ROS 2 environment and configure the workspace accordingly.","title":"Getting Started with Pixi, ROS 2, and the Robot Developer Extensions"},{"location":"pixi.html#troubleshooting","text":"If you encounter issues with Pixi or the Robot Developer Extensions, consider the following: - Ensure that Pixi is installed correctly and the pixi command is available in your terminal. - Check the Visual Studio Code output panel for any error messages related to the Robot Developer Extensions. - If you are using RoboStack, ensure that the ROS 2 packages are installed correctly and the environment is set up properly outside of the extension. - For issues related to Pixi, refer to the Pixi documentation or the Pixi Discord server for community support.","title":"Troubleshooting"},{"location":"troubleshooting.html","text":"Troubleshooting the Robot Developer Extensions ROS 2 is a complex system, and issues can arise from various sources. AI and the VSCode ecosystem are fast moving targets. This document provides troubleshooting tips for self-diagnosing and common issues encountered when using the Robot Developer Extensions for ROS 2. Output Panel The VSCode output panel provides detailed logs from the Robot Developer Extensions. You can access it by going to Output: Focus on Output View or using the shortcut Ctrl+Shift+U . In the dropdwon next to the Filter edit box, select ROS 2 . Look for any error messages or warnings that might indicate what is going wrong. IF it is not clear, copy the output and paste it into a GitHub issue or Github Discussion for further assistance. Make sure you remove any sensitive information before sharing. Github Issues Bugs and feature requests are handled through Github Issues in the Repository . If you find that you are hitting the same issue as someone else, please give a :+1: or comment on an existing issue. Please provide as much details as possible, including an isolated reproduction of the issue or a pointer to an online repository. Please remove any sensitive information before sharing. Discussions Github Discussions are provided for community driven general guidance, walkthroughs, or asynchronous support.","title":"Troubleshooting"},{"location":"troubleshooting.html#troubleshooting-the-robot-developer-extensions","text":"ROS 2 is a complex system, and issues can arise from various sources. AI and the VSCode ecosystem are fast moving targets. This document provides troubleshooting tips for self-diagnosing and common issues encountered when using the Robot Developer Extensions for ROS 2.","title":"Troubleshooting the Robot Developer Extensions"},{"location":"troubleshooting.html#output-panel","text":"The VSCode output panel provides detailed logs from the Robot Developer Extensions. You can access it by going to Output: Focus on Output View or using the shortcut Ctrl+Shift+U . In the dropdwon next to the Filter edit box, select ROS 2 . Look for any error messages or warnings that might indicate what is going wrong. IF it is not clear, copy the output and paste it into a GitHub issue or Github Discussion for further assistance. Make sure you remove any sensitive information before sharing.","title":"Output Panel"},{"location":"troubleshooting.html#github-issues","text":"Bugs and feature requests are handled through Github Issues in the Repository . If you find that you are hitting the same issue as someone else, please give a :+1: or comment on an existing issue. Please provide as much details as possible, including an isolated reproduction of the issue or a pointer to an online repository. Please remove any sensitive information before sharing.","title":"Github Issues"},{"location":"troubleshooting.html#discussions","text":"Github Discussions are provided for community driven general guidance, walkthroughs, or asynchronous support.","title":"Discussions"},{"location":"tutorials.html","text":"Tutorials and Walkthroughs Name Description Attaching to a running ROS Node Learn how to attach VS Code to a running ROS node Debugging all ROS Nodes in a launch file Learn how to set up VS Code to debug the nodes in a ROS Launch file ROSCON 2019 ROS Extension Talk Video Walkthrough of VS Code from ROSCon 2019 Deep Dive - Episode 0 About the VS Code ROS extension @ a Polyhobbyist Deep Dive - Episode 1 Installing on Windows & WSL @ a Polyhobbyist Deep Dive - Episode 2 Installing on Linux @ a Polyhobbyist Deep Dive - Episode 3 General Usage with ROS1 @ a Polyhobbyist Deep Dive - Episode 4 General Usage with ROS2 @ a Polyhobbyist Deep Dive - Episode 5 Debugging Python @ a Polyhobbyist Deep Dive - Episode 6 Debugging C++ @ a Polyhobbyist Deep Dive - Episode 7 Using with SSH @ a Polyhobbyist Deep Dive - Episode 8 Using with with Containers @ a Polyhobbyist","title":"Tutorials"},{"location":"tutorials.html#tutorials-and-walkthroughs","text":"Name Description Attaching to a running ROS Node Learn how to attach VS Code to a running ROS node Debugging all ROS Nodes in a launch file Learn how to set up VS Code to debug the nodes in a ROS Launch file ROSCON 2019 ROS Extension Talk Video Walkthrough of VS Code from ROSCon 2019 Deep Dive - Episode 0 About the VS Code ROS extension @ a Polyhobbyist Deep Dive - Episode 1 Installing on Windows & WSL @ a Polyhobbyist Deep Dive - Episode 2 Installing on Linux @ a Polyhobbyist Deep Dive - Episode 3 General Usage with ROS1 @ a Polyhobbyist Deep Dive - Episode 4 General Usage with ROS2 @ a Polyhobbyist Deep Dive - Episode 5 Debugging Python @ a Polyhobbyist Deep Dive - Episode 6 Debugging C++ @ a Polyhobbyist Deep Dive - Episode 7 Using with SSH @ a Polyhobbyist Deep Dive - Episode 8 Using with with Containers @ a Polyhobbyist","title":"Tutorials and Walkthroughs"},{"location":"usage.html","text":"Commands You can access the following commands from the Visual Studio Code command pallet , typically accessed by pressing ctrl + shift + p and typing the command name you'd like to use from the table below. Name Description ROS2: Create Terminal Create a terminal with the ROS environment. ROS2: Show Status Open a detail view showing ROS core runtime status. ROS2: Start Start ROS1 core or ROS2 Daemon. ROS2: Stop Terminate ROS core or ROS2 Daemon. ROS2: Update C++ Properties Update the C++ IntelliSense configuration to include ROS and your ROS components. ROS2: Update Python Path Update the Python IntelliSense configuration to include ROS. ROS2: Preview URDF Preview URDF and Xacro files. The display will update after the root URDF changes are saved. ROS2: Install ROS Dependencies for this workspace using rosdep Shortcut for rosdep install --from-paths src --ignore-src -r -y .","title":"Usage"},{"location":"usage.html#commands","text":"You can access the following commands from the Visual Studio Code command pallet , typically accessed by pressing ctrl + shift + p and typing the command name you'd like to use from the table below. Name Description ROS2: Create Terminal Create a terminal with the ROS environment. ROS2: Show Status Open a detail view showing ROS core runtime status. ROS2: Start Start ROS1 core or ROS2 Daemon. ROS2: Stop Terminate ROS core or ROS2 Daemon. ROS2: Update C++ Properties Update the C++ IntelliSense configuration to include ROS and your ROS components. ROS2: Update Python Path Update the Python IntelliSense configuration to include ROS. ROS2: Preview URDF Preview URDF and Xacro files. The display will update after the root URDF changes are saved. ROS2: Install ROS Dependencies for this workspace using rosdep Shortcut for rosdep install --from-paths src --ignore-src -r -y .","title":"Commands"}]}