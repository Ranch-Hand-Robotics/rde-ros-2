{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Robotics Development Extensions for ROS 2 This is a Visual Studio Code Extension that provides debugging support for Robot Operating System 2 (ROS 2) development ROS 2 on Windows, Linux and MacOS. The Robot Operating System is a trademark of Open Robotics. Features Automatic ROS environment configuration. Allows starting, stopping and viewing the ROS core status. Automatically create colcon build and test tasks. Run and Debug ROS Launch Files Resolve dependencies with rosdep shortcut Syntax highlighting for .msg , .urdf and other ROS files. IntelliSense support for ROS message files with hover information showing message properties and go-to-definition Automatically add the ROS C++ include and Python import paths. Format C++ using the ROS clang-format style. Discover and run ROS 2 tests with integrated Test Explorer support Debug a single ROS node (C++ or Python) by attaching to the process . Debug ROS nodes (C++ or Python) launched from a .launch file . Configure C++ and Python IntelliSense for ROS development Available for Microsoft Visual Studio Code and Anysphere's Cursor. Other Offerings URDF / Xacro Editing Ranch Hand Robotics offers a URDF and Xacro editor , which pairs well with this extension Robot Developer Extensions for ROS 1 For those working with ROS 1, the Robot Developer Extensions for ROS 1 are available to support you Discussions Github Discussions are provided for community driven general guidance, walkthroughs, or support. Sponsor If you find this extension useful, please consider sponsoring Ranch Hand Robotics to help support the development of this extension and other open source projects. Acknowledgements This extension is rebranded and re-released by Ranch Hand Robotics, founded by the maintainer of the ms-iot VSCode ROS Extension with permission from Microsoft. Andrew Short ( @ajshort ), original author James Giller ( @JamesGiller ) PickNikRobotics ( @PickNikRobotics ) for code formatting Microsoft ( @ms-iot ) for curating the ms-iot extension and the many contributors and users over the years.","title":"Home"},{"location":"index.html#robotics-development-extensions-for-ros-2","text":"This is a Visual Studio Code Extension that provides debugging support for Robot Operating System 2 (ROS 2) development ROS 2 on Windows, Linux and MacOS. The Robot Operating System is a trademark of Open Robotics.","title":"Robotics Development Extensions for ROS 2"},{"location":"index.html#features","text":"Automatic ROS environment configuration. Allows starting, stopping and viewing the ROS core status. Automatically create colcon build and test tasks. Run and Debug ROS Launch Files Resolve dependencies with rosdep shortcut Syntax highlighting for .msg , .urdf and other ROS files. IntelliSense support for ROS message files with hover information showing message properties and go-to-definition Automatically add the ROS C++ include and Python import paths. Format C++ using the ROS clang-format style. Discover and run ROS 2 tests with integrated Test Explorer support Debug a single ROS node (C++ or Python) by attaching to the process . Debug ROS nodes (C++ or Python) launched from a .launch file . Configure C++ and Python IntelliSense for ROS development Available for Microsoft Visual Studio Code and Anysphere's Cursor.","title":"Features"},{"location":"index.html#other-offerings","text":"","title":"Other Offerings"},{"location":"index.html#urdf-xacro-editing","text":"Ranch Hand Robotics offers a URDF and Xacro editor , which pairs well with this extension","title":"URDF / Xacro Editing"},{"location":"index.html#robot-developer-extensions-for-ros-1","text":"For those working with ROS 1, the Robot Developer Extensions for ROS 1 are available to support you","title":"Robot Developer Extensions for ROS 1"},{"location":"index.html#discussions","text":"Github Discussions are provided for community driven general guidance, walkthroughs, or support.","title":"Discussions"},{"location":"index.html#sponsor","text":"If you find this extension useful, please consider sponsoring Ranch Hand Robotics to help support the development of this extension and other open source projects.","title":"Sponsor"},{"location":"index.html#acknowledgements","text":"This extension is rebranded and re-released by Ranch Hand Robotics, founded by the maintainer of the ms-iot VSCode ROS Extension with permission from Microsoft. Andrew Short ( @ajshort ), original author James Giller ( @JamesGiller ) PickNikRobotics ( @PickNikRobotics ) for code formatting Microsoft ( @ms-iot ) for curating the ms-iot extension and the many contributors and users over the years.","title":"Acknowledgements"},{"location":"ModelContextProtocol.html","text":"Model Context Protocol (MCP) Server The Model Context Protocol (MCP) Server is a preview feature of the Robot Developer Extension for ROS 2. It allows Large Language Models (LLMs) to introspect a running ROS 2 system, providing a way to query and interact with the ROS 2 environment programmatically. Model Context Protocol (MCP) is a protocol designed by Anthropic to enable LLMs to understand and interact with complex systems. It provides a structured way for LLMs to query system state, access information about components, and perform actions based on the system's context. NOTE: This feature is in preview and may not be fully stable. It is intended for experimental use and feedback. The extension creates a python virtual environment which resides inside the extension install to run the MCP server, which is separate from the ROS 2 environment. This allows it to run independently of the ROS 2 nodes and provides a clean interface for LLMs to interact with the ROS 2 system. This is experimental code, and may cause issues with your ROS 2 system when launched. Please use with caution and report any issues you encounter. Features Provides a server that can be queried by LLMs to understand the current state of a ROS 2 system. Allows LLMs to access information about nodes, topics, services, and parameters in the ROS 2 environment. Facilitates the development of intelligent applications that can leverage the capabilities of ROS 2 through natural language queries. Enables advanced use cases such as automated debugging, system monitoring, and dynamic configuration of ROS 2 nodes. Getting Started To use the MCP Server for ROS 2, Start the ROS 2 MCP Server using the command palette (CTRL-SHIFT-P) and selecting ROS2: Start MCP Server . The first time you run the MCP Server, the extension will create a Python virtual environment. This process may require a super user password to install the required dependencie. Please open the terminal pane and enter your password in the MCP terminal if prompted. This extension will start the server and make it available for LLMs to connect through a configurable endpoint that defaults to http://localhost:3002/sse . Available Tools Tool Name Category Description get_nodes Node Management Returns a list of running ROS nodes get_node_info Node Management Returns detailed information about a specific ROS node by name list_topics Topic Operations Lists available ROS topics with optional type information get_topic_info Topic Operations Get detailed information about a specific ROS topic echo_topic Topic Operations Echo messages from a topic for monitoring publish_to_topic Topic Operations Publish a message to a specific topic list_services Service Operations Lists available ROS services with optional type information get_service_type Service Operations Get the type of a specific ROS service call_service Service Operations Call a ROS service with specified request parameters list_parameters Parameter Management List all parameters of a specific node get_parameter Parameter Management Get the value of a specific parameter from a node set_parameter Parameter Management Set the value of a parameter for a node list_actions Action Operations Lists available ROS actions with optional type information get_action_info Action Operations Get detailed information about a specific ROS action send_action_goal Action Operations Send a goal to an action server record_bag Bag Operations Record ROS topics to a bag file play_bag Bag Operations Play back a ROS bag file get_bag_info Bag Operations Get information about a bag file list_interfaces Interface Inspection List available ROS interfaces (messages, services, actions) show_interface Interface Inspection Show the definition of a specific interface list_packages Package Management List all available ROS packages package_executables Package Management List executables in a specific ROS package get_package_manifest Package Management Get package manifest (package.xml) information list_launch_files Launch Operations List available launch files in a ROS package launch_file Launch Operations Launch a ROS package with specified launch file get_launch_parameters Launch Operations Get parameters available in a launch file run_package_executable Execution Run a ROS package executable with optional arguments list_lifecycle_nodes Lifecycle Management List nodes with lifecycle support get_lifecycle_state Lifecycle Management Get the current lifecycle state of a node set_lifecycle_transition Lifecycle Management Trigger a lifecycle state transition for a node kill_process Utility Kill a ROS process by process ID run_doctor Diagnostics Run ROS 2 doctor to check system and ROS 2 setup Example Session (Graphical) Example Session (Textual) This is an example of how the MCP Server can be used to introspect a ROS 2 system: I'll help you check the running lifecycle nodes in your ROS 2 system. Let me start by examining what lifecycle nodes are currently running. ROS 2 (MCP Server) Now let me get information about the lifecycle nodes specifically: ROS 2 (MCP Server) Let me get detailed information about the lifecycle node and its current state: ROS 2 (MCP Server) Let me try without the leading slash: ROS 2 (MCP Server) Now let me get the current lifecycle state of the lc_talker node: ROS 2 (MCP Server) Let me also check if there are any other nodes that might be lifecycle nodes by checking the lc_listener: ROS 2 (MCP Server) Let me try to get the lifecycle state of lc_listener as well: ROS 2 (MCP Server) Let me get more details about the lifecycle services available for the lc_talker: ROS 2 (MCP Server) ROS 2 (MCP Server) Based on my analysis of the running lifecycle nodes in your ROS 2 system, here's what I found: Running Lifecycle Nodes lc_talker - Primary Lifecycle Node Current State: unconfigured (ID: 1) Node Type: This is the LifecycleTalker node from your lifecycle_talker.cpp file Purpose: A demonstration lifecycle node that publishes string messages to the /lifecycle_chatter topic Available Lifecycle States The lc_talker node supports the standard ROS 2 lifecycle states: Primary States: unknown (0) unconfigured (1) \u2190 Current state inactive (2) active (3) finalized (4) Transition States: configuring (10) cleaningup (11) shuttingdown (12) activating (13) deactivating (14) errorprocessing (15) Current Available Transitions From the unconfigured state, the node can transition to: configure \u2192 moves to configuring state (then to inactive) shutdown \u2192 moves to shuttingdown state (then to finalized) Node Features The lc_talker node provides these lifecycle-specific services: /lc_talker/change_state - Change the lifecycle state /lc_talker/get_state - Get current state /lc_talker/get_available_states - List all possible states /lc_talker/get_available_transitions - Get valid transitions from current state Topics * Publishers: /lifecycle_chatter (std_msgs/String) - publishes messages when active * System Topics: /lc_talker/transition_event - publishes state transition events Conclusion The included model context protocol server offers a powerful way to introspect and interact with ROS 2 systems. It allows you to query the state of nodes, topics, services, and parameters, enabling advanced use cases such as automated debugging, system monitoring, and dynamic configuration of ROS 2 nodes. We'd love to hear your feedback on this feature and any suggestions for improvements.","title":"Model Context Protocol (MCP) Server"},{"location":"ModelContextProtocol.html#model-context-protocol-mcp-server","text":"The Model Context Protocol (MCP) Server is a preview feature of the Robot Developer Extension for ROS 2. It allows Large Language Models (LLMs) to introspect a running ROS 2 system, providing a way to query and interact with the ROS 2 environment programmatically. Model Context Protocol (MCP) is a protocol designed by Anthropic to enable LLMs to understand and interact with complex systems. It provides a structured way for LLMs to query system state, access information about components, and perform actions based on the system's context. NOTE: This feature is in preview and may not be fully stable. It is intended for experimental use and feedback. The extension creates a python virtual environment which resides inside the extension install to run the MCP server, which is separate from the ROS 2 environment. This allows it to run independently of the ROS 2 nodes and provides a clean interface for LLMs to interact with the ROS 2 system. This is experimental code, and may cause issues with your ROS 2 system when launched. Please use with caution and report any issues you encounter.","title":"Model Context Protocol (MCP) Server"},{"location":"ModelContextProtocol.html#features","text":"Provides a server that can be queried by LLMs to understand the current state of a ROS 2 system. Allows LLMs to access information about nodes, topics, services, and parameters in the ROS 2 environment. Facilitates the development of intelligent applications that can leverage the capabilities of ROS 2 through natural language queries. Enables advanced use cases such as automated debugging, system monitoring, and dynamic configuration of ROS 2 nodes.","title":"Features"},{"location":"ModelContextProtocol.html#getting-started","text":"To use the MCP Server for ROS 2, Start the ROS 2 MCP Server using the command palette (CTRL-SHIFT-P) and selecting ROS2: Start MCP Server . The first time you run the MCP Server, the extension will create a Python virtual environment. This process may require a super user password to install the required dependencie. Please open the terminal pane and enter your password in the MCP terminal if prompted. This extension will start the server and make it available for LLMs to connect through a configurable endpoint that defaults to http://localhost:3002/sse .","title":"Getting Started"},{"location":"ModelContextProtocol.html#available-tools","text":"Tool Name Category Description get_nodes Node Management Returns a list of running ROS nodes get_node_info Node Management Returns detailed information about a specific ROS node by name list_topics Topic Operations Lists available ROS topics with optional type information get_topic_info Topic Operations Get detailed information about a specific ROS topic echo_topic Topic Operations Echo messages from a topic for monitoring publish_to_topic Topic Operations Publish a message to a specific topic list_services Service Operations Lists available ROS services with optional type information get_service_type Service Operations Get the type of a specific ROS service call_service Service Operations Call a ROS service with specified request parameters list_parameters Parameter Management List all parameters of a specific node get_parameter Parameter Management Get the value of a specific parameter from a node set_parameter Parameter Management Set the value of a parameter for a node list_actions Action Operations Lists available ROS actions with optional type information get_action_info Action Operations Get detailed information about a specific ROS action send_action_goal Action Operations Send a goal to an action server record_bag Bag Operations Record ROS topics to a bag file play_bag Bag Operations Play back a ROS bag file get_bag_info Bag Operations Get information about a bag file list_interfaces Interface Inspection List available ROS interfaces (messages, services, actions) show_interface Interface Inspection Show the definition of a specific interface list_packages Package Management List all available ROS packages package_executables Package Management List executables in a specific ROS package get_package_manifest Package Management Get package manifest (package.xml) information list_launch_files Launch Operations List available launch files in a ROS package launch_file Launch Operations Launch a ROS package with specified launch file get_launch_parameters Launch Operations Get parameters available in a launch file run_package_executable Execution Run a ROS package executable with optional arguments list_lifecycle_nodes Lifecycle Management List nodes with lifecycle support get_lifecycle_state Lifecycle Management Get the current lifecycle state of a node set_lifecycle_transition Lifecycle Management Trigger a lifecycle state transition for a node kill_process Utility Kill a ROS process by process ID run_doctor Diagnostics Run ROS 2 doctor to check system and ROS 2 setup","title":"Available Tools"},{"location":"ModelContextProtocol.html#example-session-graphical","text":"","title":"Example Session (Graphical)"},{"location":"ModelContextProtocol.html#example-session-textual","text":"This is an example of how the MCP Server can be used to introspect a ROS 2 system: I'll help you check the running lifecycle nodes in your ROS 2 system. Let me start by examining what lifecycle nodes are currently running. ROS 2 (MCP Server) Now let me get information about the lifecycle nodes specifically: ROS 2 (MCP Server) Let me get detailed information about the lifecycle node and its current state: ROS 2 (MCP Server) Let me try without the leading slash: ROS 2 (MCP Server) Now let me get the current lifecycle state of the lc_talker node: ROS 2 (MCP Server) Let me also check if there are any other nodes that might be lifecycle nodes by checking the lc_listener: ROS 2 (MCP Server) Let me try to get the lifecycle state of lc_listener as well: ROS 2 (MCP Server) Let me get more details about the lifecycle services available for the lc_talker: ROS 2 (MCP Server) ROS 2 (MCP Server) Based on my analysis of the running lifecycle nodes in your ROS 2 system, here's what I found: Running Lifecycle Nodes lc_talker - Primary Lifecycle Node Current State: unconfigured (ID: 1) Node Type: This is the LifecycleTalker node from your lifecycle_talker.cpp file Purpose: A demonstration lifecycle node that publishes string messages to the /lifecycle_chatter topic Available Lifecycle States The lc_talker node supports the standard ROS 2 lifecycle states: Primary States: unknown (0) unconfigured (1) \u2190 Current state inactive (2) active (3) finalized (4) Transition States: configuring (10) cleaningup (11) shuttingdown (12) activating (13) deactivating (14) errorprocessing (15) Current Available Transitions From the unconfigured state, the node can transition to: configure \u2192 moves to configuring state (then to inactive) shutdown \u2192 moves to shuttingdown state (then to finalized) Node Features The lc_talker node provides these lifecycle-specific services: /lc_talker/change_state - Change the lifecycle state /lc_talker/get_state - Get current state /lc_talker/get_available_states - List all possible states /lc_talker/get_available_transitions - Get valid transitions from current state Topics * Publishers: /lifecycle_chatter (std_msgs/String) - publishes messages when active * System Topics: /lc_talker/transition_event - publishes state transition events","title":"Example Session (Textual)"},{"location":"ModelContextProtocol.html#conclusion","text":"The included model context protocol server offers a powerful way to introspect and interact with ROS 2 systems. It allows you to query the state of nodes, topics, services, and parameters, enabling advanced use cases such as automated debugging, system monitoring, and dynamic configuration of ROS 2 nodes. We'd love to hear your feedback on this feature and any suggestions for improvements.","title":"Conclusion"},{"location":"configuration.html","text":"ROS Launch Configuration options The ROS Launch configuration block supports the following configuration: Option Description name The name which will be displayed in the VS Code UI launch configuration request launch or attach for launching a ROS launch file, or attaching using the attach UI for Pyton or C++ target the launch file path type must be ros to indicate to VS Code that this is a ROS launch configuration arguments Arguments passed to roslaunch such as map:=/foo.yaml' symbolSearchPath A semicolon delimited search path for Windows symbols, including ROS for Windows symbols downloaded from https://ros-win.visualstudio.com/ros-win/_build additionalSOLibSearchPath A semicolon delimited search path for Linux symbols sourceFileMap A mapping of Source files from where Symbols expect and the location you have on disk. launch If specified, a list of executables to just launch, attaching to everything else. e.g. \"launch\": [\"rviz\", \"gz\"] which prevents attaching a debugger to rviz and gazebo. NOTE: the debugger will ignore file extension: x.py is the same as x.exe. attachDebugger If specified, a list of executables to debug. \"attachDebugger\": [\"my_ros_node\"] will only attach to my_ros_node.exe, my_ros_node.py or my_ros_node. Workspace and Global Settings The ROS extension supports the following global settings, which can be overridden in the workspace. Json Option Setting Name Description ros.distro ROS installation distro to be sourced The Distribution to be sourced. On linux, this cause the extension to look for the ROS setup script in /opt/ros/{distro}/setup.bash . On Windows, c:\\opt\\ros\\{distro}\\setup.bat ros.rosSetupScript ROS workspace setup script. Overrides ros.distro. If specified, this will cause the extension to source this script before generating the launch debugging or ROS terminal environment. This overrides the ros.distro, and can be used to specify user scripts or ROS installs in a different location. ros.isolateEnvironment Specify if the extension should not capture the environment VS Code is running in to pass to child processes. Off by default, This setting will prevent the ROS extension from capturing it's hosting environment in case this would conflict with the ROS environment. Workspace example: \u2514\u2500\u2500 .vscode \u251c\u2500\u2500 launch.json \u251c\u2500\u2500 settings.json \u2514\u2500\u2500 tasks.json settings.json { \"ros.distro\" : \"foxy\" , \"ros.rosSetupScript\" : \"/opt/ros/foxy/install/setup.bash\" , \"ros.isolateEnvironment\" : \"false\" }","title":"Configuration"},{"location":"configuration.html#ros-launch-configuration-options","text":"The ROS Launch configuration block supports the following configuration: Option Description name The name which will be displayed in the VS Code UI launch configuration request launch or attach for launching a ROS launch file, or attaching using the attach UI for Pyton or C++ target the launch file path type must be ros to indicate to VS Code that this is a ROS launch configuration arguments Arguments passed to roslaunch such as map:=/foo.yaml' symbolSearchPath A semicolon delimited search path for Windows symbols, including ROS for Windows symbols downloaded from https://ros-win.visualstudio.com/ros-win/_build additionalSOLibSearchPath A semicolon delimited search path for Linux symbols sourceFileMap A mapping of Source files from where Symbols expect and the location you have on disk. launch If specified, a list of executables to just launch, attaching to everything else. e.g. \"launch\": [\"rviz\", \"gz\"] which prevents attaching a debugger to rviz and gazebo. NOTE: the debugger will ignore file extension: x.py is the same as x.exe. attachDebugger If specified, a list of executables to debug. \"attachDebugger\": [\"my_ros_node\"] will only attach to my_ros_node.exe, my_ros_node.py or my_ros_node.","title":"ROS Launch Configuration options"},{"location":"configuration.html#workspace-and-global-settings","text":"The ROS extension supports the following global settings, which can be overridden in the workspace. Json Option Setting Name Description ros.distro ROS installation distro to be sourced The Distribution to be sourced. On linux, this cause the extension to look for the ROS setup script in /opt/ros/{distro}/setup.bash . On Windows, c:\\opt\\ros\\{distro}\\setup.bat ros.rosSetupScript ROS workspace setup script. Overrides ros.distro. If specified, this will cause the extension to source this script before generating the launch debugging or ROS terminal environment. This overrides the ros.distro, and can be used to specify user scripts or ROS installs in a different location. ros.isolateEnvironment Specify if the extension should not capture the environment VS Code is running in to pass to child processes. Off by default, This setting will prevent the ROS extension from capturing it's hosting environment in case this would conflict with the ROS environment. Workspace example: \u2514\u2500\u2500 .vscode \u251c\u2500\u2500 launch.json \u251c\u2500\u2500 settings.json \u2514\u2500\u2500 tasks.json settings.json { \"ros.distro\" : \"foxy\" , \"ros.rosSetupScript\" : \"/opt/ros/foxy/install/setup.bash\" , \"ros.isolateEnvironment\" : \"false\" }","title":"Workspace and Global Settings"},{"location":"debug-support.html","text":"Debug ROS Nodes One of the key goals of this extension is to provide a streamlined debugging experience for ROS nodes. To achieve this, this extension aims to help developers utilize the debugging capabilities provided by Visual Studio Code. This document covers instructions of how to use such functionalities. Attach This extension enables a bootstrapped debugging experience for debugging a ROS (Python or C++) node by attaching to the process. To get started, create a ros -type debug configuration with an attach request: (use Ctrl - Space to bring up the autocomplete dropdown) Attaching to a Python node Attaching to a C++ node Launch This extension enables a streamlined debugging experience for debugging a ROS (Python or C++) node in a ROS launch file similar to a native debug flow. To get started, create a ros -type debug configuration with a launch request: Launch and debug Python and C++ nodes Note Debugging functionality provided by this extension has dependencies on VS Code\u2019s C++ and Python extensions, and those have dependencies on the version of VS Code. To ensure everything works as expected, please make sure to have everything up-to-date. To debug a C++ executable, please make sure the binary is built with debug symbols (e.g. -DCMAKE_BUILD_TYPE=RelWithDebInfo , read more about CMAKE_BUILD_TYPE here ). To use VS Code's C++ extension with MSVC on Windows, please make sure the VS Code instance is launched from a Visual Studio command prompt.","title":"Debug ROS Nodes"},{"location":"debug-support.html#debug-ros-nodes","text":"One of the key goals of this extension is to provide a streamlined debugging experience for ROS nodes. To achieve this, this extension aims to help developers utilize the debugging capabilities provided by Visual Studio Code. This document covers instructions of how to use such functionalities.","title":"Debug ROS Nodes"},{"location":"debug-support.html#attach","text":"This extension enables a bootstrapped debugging experience for debugging a ROS (Python or C++) node by attaching to the process. To get started, create a ros -type debug configuration with an attach request: (use Ctrl - Space to bring up the autocomplete dropdown)","title":"Attach"},{"location":"debug-support.html#attaching-to-a-python-node","text":"","title":"Attaching to a Python node"},{"location":"debug-support.html#attaching-to-a-c-node","text":"","title":"Attaching to a C++ node"},{"location":"debug-support.html#launch","text":"This extension enables a streamlined debugging experience for debugging a ROS (Python or C++) node in a ROS launch file similar to a native debug flow. To get started, create a ros -type debug configuration with a launch request:","title":"Launch"},{"location":"debug-support.html#launch-and-debug-python-and-c-nodes","text":"","title":"Launch and debug Python and C++ nodes"},{"location":"debug-support.html#note","text":"Debugging functionality provided by this extension has dependencies on VS Code\u2019s C++ and Python extensions, and those have dependencies on the version of VS Code. To ensure everything works as expected, please make sure to have everything up-to-date. To debug a C++ executable, please make sure the binary is built with debug symbols (e.g. -DCMAKE_BUILD_TYPE=RelWithDebInfo , read more about CMAKE_BUILD_TYPE here ). To use VS Code's C++ extension with MSVC on Windows, please make sure the VS Code instance is launched from a Visual Studio command prompt.","title":"Note"},{"location":"intellisense.html","text":"IntelliSense Support The Robot Developer Extensions for ROS 2 provides rich IntelliSense support for ROS message files ( .msg , .srv , .action ), making it easier to work with ROS interfaces. Message File IntelliSense When working with ROS message files, the extension provides several IntelliSense features to help you understand message structures. Hover Information Hovering over message types or field names displays detailed information about the type, including its properties. Hovering Over Message Types When you hover over a message type (such as geometry_msgs/Point , std_msgs/Header , or builtin_interfaces/Duration ), the hover tooltip displays: Package name : The ROS package containing the message Message type : The name of the message Properties : A formatted list of all fields in the message, including: Field types and names Array notation (fixed size [N] or dynamic [] ) Default values and constants Inline comments from the message definition Example : Hovering over geometry_msgs/Vector3 shows: geometry_msgs/Vector3 Package: Geometric primitive messages for representing common geometric shapes Message Type: Vector3 Properties: float64 x float64 y float64 z Hovering Over Field Names Hovering over a field name provides comprehensive information about both the field and its type: The field declaration with any default values Inline comments associated with the field Complete type documentation (same as hovering over the type) All properties of the field's message type Example : Hovering over angular_velocity in the line: geometry_msgs/Vector3 angular_velocity Shows the field declaration, followed by complete documentation about the Vector3 type and its properties. Built-in Types When hovering over ROS built-in types (such as int32 , float64 , string , etc.), the extension displays: Type name Description of the type Range information where applicable Array information if the field is an array Example : Hovering over float64 shows: float64 64-bit floating point number (double precision) Workspace and System Packages The IntelliSense features work seamlessly with both: Workspace packages : Messages defined in your current workspace System-installed packages : Messages from installed ROS packages (e.g., geometry_msgs , sensor_msgs , builtin_interfaces ) The extension automatically searches for message definitions in: 1. Your workspace folders 2. ROS package paths (obtained from the ROS environment) This means you get the same rich hover information whether you're working with custom messages or standard ROS messages. Go to Definition Press F12 or Ctrl+Click (Cmd+Click on macOS) on a message type to jump to its definition file. This works for both workspace and system-installed packages. Supported File Types IntelliSense features are available for: .msg files : ROS message definitions .srv files : ROS service definitions .action files : ROS action definitions C++ and Python IntelliSense For C++ and Python code that uses ROS, you need to configure IntelliSense to include ROS paths: C++ IntelliSense Configuration Run the command ROS2: Update C++ Properties from the command palette to automatically configure C++ IntelliSense with ROS include paths. This updates your workspace's c_cpp_properties.json file to include: - ROS installation paths - Your workspace's package include directories - Appropriate compiler settings Python IntelliSense Configuration Run the command ROS2: Update Python Path from the command palette to configure Python IntelliSense with ROS Python paths. This updates your workspace settings to include: - ROS Python module paths - Your workspace's Python packages Tips Keep your ROS environment sourced : Make sure your ROS environment is properly sourced so the extension can find all package definitions Reload after installing packages : If you install new ROS packages, you may need to reload the VS Code window to pick up the new definitions Check hover information during development : Use hover information to quickly verify message structures without switching files Combine with Go to Definition : Use hover to preview, then F12 to dive into the full definition when needed","title":"IntelliSense Support"},{"location":"intellisense.html#intellisense-support","text":"The Robot Developer Extensions for ROS 2 provides rich IntelliSense support for ROS message files ( .msg , .srv , .action ), making it easier to work with ROS interfaces.","title":"IntelliSense Support"},{"location":"intellisense.html#message-file-intellisense","text":"When working with ROS message files, the extension provides several IntelliSense features to help you understand message structures.","title":"Message File IntelliSense"},{"location":"intellisense.html#hover-information","text":"Hovering over message types or field names displays detailed information about the type, including its properties.","title":"Hover Information"},{"location":"intellisense.html#hovering-over-message-types","text":"When you hover over a message type (such as geometry_msgs/Point , std_msgs/Header , or builtin_interfaces/Duration ), the hover tooltip displays: Package name : The ROS package containing the message Message type : The name of the message Properties : A formatted list of all fields in the message, including: Field types and names Array notation (fixed size [N] or dynamic [] ) Default values and constants Inline comments from the message definition Example : Hovering over geometry_msgs/Vector3 shows: geometry_msgs/Vector3 Package: Geometric primitive messages for representing common geometric shapes Message Type: Vector3 Properties: float64 x float64 y float64 z","title":"Hovering Over Message Types"},{"location":"intellisense.html#hovering-over-field-names","text":"Hovering over a field name provides comprehensive information about both the field and its type: The field declaration with any default values Inline comments associated with the field Complete type documentation (same as hovering over the type) All properties of the field's message type Example : Hovering over angular_velocity in the line: geometry_msgs/Vector3 angular_velocity Shows the field declaration, followed by complete documentation about the Vector3 type and its properties.","title":"Hovering Over Field Names"},{"location":"intellisense.html#built-in-types","text":"When hovering over ROS built-in types (such as int32 , float64 , string , etc.), the extension displays: Type name Description of the type Range information where applicable Array information if the field is an array Example : Hovering over float64 shows: float64 64-bit floating point number (double precision)","title":"Built-in Types"},{"location":"intellisense.html#workspace-and-system-packages","text":"The IntelliSense features work seamlessly with both: Workspace packages : Messages defined in your current workspace System-installed packages : Messages from installed ROS packages (e.g., geometry_msgs , sensor_msgs , builtin_interfaces ) The extension automatically searches for message definitions in: 1. Your workspace folders 2. ROS package paths (obtained from the ROS environment) This means you get the same rich hover information whether you're working with custom messages or standard ROS messages.","title":"Workspace and System Packages"},{"location":"intellisense.html#go-to-definition","text":"Press F12 or Ctrl+Click (Cmd+Click on macOS) on a message type to jump to its definition file. This works for both workspace and system-installed packages.","title":"Go to Definition"},{"location":"intellisense.html#supported-file-types","text":"IntelliSense features are available for: .msg files : ROS message definitions .srv files : ROS service definitions .action files : ROS action definitions","title":"Supported File Types"},{"location":"intellisense.html#c-and-python-intellisense","text":"For C++ and Python code that uses ROS, you need to configure IntelliSense to include ROS paths:","title":"C++ and Python IntelliSense"},{"location":"intellisense.html#c-intellisense-configuration","text":"Run the command ROS2: Update C++ Properties from the command palette to automatically configure C++ IntelliSense with ROS include paths. This updates your workspace's c_cpp_properties.json file to include: - ROS installation paths - Your workspace's package include directories - Appropriate compiler settings","title":"C++ IntelliSense Configuration"},{"location":"intellisense.html#python-intellisense-configuration","text":"Run the command ROS2: Update Python Path from the command palette to configure Python IntelliSense with ROS Python paths. This updates your workspace settings to include: - ROS Python module paths - Your workspace's Python packages","title":"Python IntelliSense Configuration"},{"location":"intellisense.html#tips","text":"Keep your ROS environment sourced : Make sure your ROS environment is properly sourced so the extension can find all package definitions Reload after installing packages : If you install new ROS packages, you may need to reload the VS Code window to pick up the new definitions Check hover information during development : Use hover information to quickly verify message structures without switching files Combine with Go to Definition : Use hover to preview, then F12 to dive into the full definition when needed","title":"Tips"},{"location":"launchdebugging.html","text":"Launch Debugging Launch Debugging The Visual Studio Code extension for ROS supports launch debugging for ROS 2 nodes, written in Python and C++. The ROS node or nodes to be debugged must be placed in a ROS launch file with the extension .xml or .py . Automatic creation of a launch.json with ROS Launch support .vscode/launch.json is a file which defines a debug launch configuration within VS Code. To create a .vscode/launch.json with ROS debugging support C++ or Python file is selected, vscode uses the selected file to seed the launch creation UI. Click the Run and Debug tab on the left sidebar Select the link to create a .vscode/launch.json file. VS Code will drop down from the command pallet with a list of options, which includes 'ROS'. Select this option. In the next dialog, type the name of the ROS package containing a launch file you'd like to debug. Then find the launch file. Once this is created, you can use the play button in the title bar, or the \"start debugging\" accelerator key, or from the command palle (CTRL-SHIFT-P), select Debug: Start Debugging . NOTE: Other VS Code extensions may interfere with the selection list. If you do not see ROS in the first drop down list, you'll need to create a new file called .vscode/launch.json , then use the manual option described below. Other Notes: * Create a new ROS launch file with just the nodes you'd like to debug, and a separate ROS launch file with all other ROS nodes. * Debugging a launch file with Gazebo or rviz is not supported as this time. Please split these out into separate launch files. * ros2 run is not supported. * Traditional XML launch files are supported for ROS1, and both python and XML based launch files are supported for ROS2. Manually adding a launch file to an existing launch.json If you have an existing launch.json file (or if there is an extension conflict as mentioned above), you can manually add a launch configuration by adding a new block like this. { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS2: Launch my file\" , \"request\" : \"launch\" , \"target\" : \"<full path to your launch.py or launch file>\" , \"launch\" : [ \"rviz\" , \"gz\" ], \"type\" : \"ros2\" } ] } Be sure to include the full path to your launch file, including file extension. Environment Variables You can pass environment variables to your ROS 2 launch configuration in two ways: Using the env property You can define environment variables directly in your launch.json using the env property: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS2: Launch with env\" , \"request\" : \"launch\" , \"target\" : \"${workspaceFolder}/launch/my_launch.py\" , \"type\" : \"ros2\" , \"env\" : { \"ROS_DOMAIN_ID\" : \"42\" , \"ROS_LOCALHOST_ONLY\" : \"1\" , \"MY_CUSTOM_VAR\" : \"value\" } } ] } Using the envFile property You can also load environment variables from a file using the envFile property. This is useful when you have many environment variables or want to share them across multiple configurations. Create a .env file in your workspace (e.g., .env or .env.ros2 ): # .env file ROS_DOMAIN_ID = 42 ROS_LOCALHOST_ONLY = 1 MY_CUSTOM_VAR = value PATH_TO_CONFIG = /path/to/config # Comments and empty lines are ignored # Quotes are optional but can be used for values with spaces MESSAGE = \"Hello ROS 2\" Then reference it in your launch.json: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS2: Launch with envFile\" , \"request\" : \"launch\" , \"target\" : \"${workspaceFolder}/launch/my_launch.py\" , \"type\" : \"ros2\" , \"envFile\" : \"${workspaceFolder}/.env\" } ] } Combining env and envFile You can use both env and envFile together. Variables defined in env take precedence over those in envFile : { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS2: Launch with env and envFile\" , \"request\" : \"launch\" , \"target\" : \"${workspaceFolder}/launch/my_launch.py\" , \"type\" : \"ros2\" , \"envFile\" : \"${workspaceFolder}/.env\" , \"env\" : { \"ROS_DOMAIN_ID\" : \"99\" // This overrides the value from .env } } ] } This allows you to have a common set of environment variables in a file and override specific ones as needed.","title":"Launchdebugging"},{"location":"launchdebugging.html#launch-debugging","text":"","title":"Launch Debugging"},{"location":"launchdebugging.html#launch-debugging_1","text":"The Visual Studio Code extension for ROS supports launch debugging for ROS 2 nodes, written in Python and C++. The ROS node or nodes to be debugged must be placed in a ROS launch file with the extension .xml or .py .","title":"Launch Debugging"},{"location":"launchdebugging.html#automatic-creation-of-a-launchjson-with-ros-launch-support","text":".vscode/launch.json is a file which defines a debug launch configuration within VS Code. To create a .vscode/launch.json with ROS debugging support C++ or Python file is selected, vscode uses the selected file to seed the launch creation UI. Click the Run and Debug tab on the left sidebar Select the link to create a .vscode/launch.json file. VS Code will drop down from the command pallet with a list of options, which includes 'ROS'. Select this option. In the next dialog, type the name of the ROS package containing a launch file you'd like to debug. Then find the launch file. Once this is created, you can use the play button in the title bar, or the \"start debugging\" accelerator key, or from the command palle (CTRL-SHIFT-P), select Debug: Start Debugging . NOTE: Other VS Code extensions may interfere with the selection list. If you do not see ROS in the first drop down list, you'll need to create a new file called .vscode/launch.json , then use the manual option described below. Other Notes: * Create a new ROS launch file with just the nodes you'd like to debug, and a separate ROS launch file with all other ROS nodes. * Debugging a launch file with Gazebo or rviz is not supported as this time. Please split these out into separate launch files. * ros2 run is not supported. * Traditional XML launch files are supported for ROS1, and both python and XML based launch files are supported for ROS2.","title":"Automatic creation of a launch.json with ROS Launch support"},{"location":"launchdebugging.html#manually-adding-a-launch-file-to-an-existing-launchjson","text":"If you have an existing launch.json file (or if there is an extension conflict as mentioned above), you can manually add a launch configuration by adding a new block like this. { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS2: Launch my file\" , \"request\" : \"launch\" , \"target\" : \"<full path to your launch.py or launch file>\" , \"launch\" : [ \"rviz\" , \"gz\" ], \"type\" : \"ros2\" } ] } Be sure to include the full path to your launch file, including file extension.","title":"Manually adding a launch file to an existing launch.json"},{"location":"launchdebugging.html#environment-variables","text":"You can pass environment variables to your ROS 2 launch configuration in two ways:","title":"Environment Variables"},{"location":"launchdebugging.html#using-the-env-property","text":"You can define environment variables directly in your launch.json using the env property: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS2: Launch with env\" , \"request\" : \"launch\" , \"target\" : \"${workspaceFolder}/launch/my_launch.py\" , \"type\" : \"ros2\" , \"env\" : { \"ROS_DOMAIN_ID\" : \"42\" , \"ROS_LOCALHOST_ONLY\" : \"1\" , \"MY_CUSTOM_VAR\" : \"value\" } } ] }","title":"Using the env property"},{"location":"launchdebugging.html#using-the-envfile-property","text":"You can also load environment variables from a file using the envFile property. This is useful when you have many environment variables or want to share them across multiple configurations. Create a .env file in your workspace (e.g., .env or .env.ros2 ): # .env file ROS_DOMAIN_ID = 42 ROS_LOCALHOST_ONLY = 1 MY_CUSTOM_VAR = value PATH_TO_CONFIG = /path/to/config # Comments and empty lines are ignored # Quotes are optional but can be used for values with spaces MESSAGE = \"Hello ROS 2\" Then reference it in your launch.json: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS2: Launch with envFile\" , \"request\" : \"launch\" , \"target\" : \"${workspaceFolder}/launch/my_launch.py\" , \"type\" : \"ros2\" , \"envFile\" : \"${workspaceFolder}/.env\" } ] }","title":"Using the envFile property"},{"location":"launchdebugging.html#combining-env-and-envfile","text":"You can use both env and envFile together. Variables defined in env take precedence over those in envFile : { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS2: Launch with env and envFile\" , \"request\" : \"launch\" , \"target\" : \"${workspaceFolder}/launch/my_launch.py\" , \"type\" : \"ros2\" , \"envFile\" : \"${workspaceFolder}/.env\" , \"env\" : { \"ROS_DOMAIN_ID\" : \"99\" // This overrides the value from .env } } ] } This allows you to have a common set of environment variables in a file and override specific ones as needed.","title":"Combining env and envFile"},{"location":"openvsx.html","text":"Available on Open-VSX.org This extension is published on https://open-vsx.org/ , making it easy to install and update from Cursor . Compatibility The extension is specifically tested on Cursor to ensure the fullest compatibility and a seamless experience. All features available in Visual Studio Code are supported when using Cursor. NOTE: Due to tight coupling with debuggers, this extension depends specifically on vadimcn.vscode-lldb . Installation To install the extension from OpenVSX, search for it from the Open-VSX marketplace or visit the RDE ROS 2 listing . Feedback If you encounter any issues using this extension, please open an issue in the repository.","title":"Available on Open-VSX.org"},{"location":"openvsx.html#available-on-open-vsxorg","text":"This extension is published on https://open-vsx.org/ , making it easy to install and update from Cursor .","title":"Available on Open-VSX.org"},{"location":"openvsx.html#compatibility","text":"The extension is specifically tested on Cursor to ensure the fullest compatibility and a seamless experience. All features available in Visual Studio Code are supported when using Cursor. NOTE: Due to tight coupling with debuggers, this extension depends specifically on vadimcn.vscode-lldb .","title":"Compatibility"},{"location":"openvsx.html#installation","text":"To install the extension from OpenVSX, search for it from the Open-VSX marketplace or visit the RDE ROS 2 listing .","title":"Installation"},{"location":"openvsx.html#feedback","text":"If you encounter any issues using this extension, please open an issue in the repository.","title":"Feedback"},{"location":"pixi.html","text":"Pixi for ROS 2 Pixi by prefix.dev is a next generation package manager, which includes support for ROS 2 development environments. It provides a cross-platform way to manage ROS 2 workspaces, dependencies, and tools. Open Robotics has standardized on Pixi for Windows development. RoboStack & Open Robotics Open Robotics has partnered with RoboStack to provide a Pixi-based ROS 2 development environment. This environment is designed to work seamlessly with the Robot Developer Extensions for ROS 2, providing a consistent and easy-to-use development experience across platforms. Open Robotics provides an official distribution of core ROS Components through Open Robotics build system. This distribution is recommended for production use cases. RoboStack provides a community-driven distribution of ROS 2 packages, which includes additional packages not available in the Open Robotics distribution. This distribution is recommended for development and testing purposes. Getting Started with Pixi, ROS 2, and the Robot Developer Extensions Install Pixi : Follow the instructions on the Pixi website to install Pixi on your system. Install Visual Studio : Download and install Visual Studio . This is needed for building ROS 2 packages on Windows. Install Visual Studio Code : Download and install Visual Studio Code . Install ROS 2 through RoboStack or Open Robotics depending on your use case: For Development and Testing, follow the instructions on the RoboStack website . For Production Environments, follow the instructions on the ros.org . Install the Robot Developer Extensions (RDE) for ROS 2 : Install the Robot Developer Extensions for ROS 2 from the Visual Studio Code Marketplace or Open-Vsx.org . Configure Pixi in RDE Open the Workspace settings. Set the ROS2.usePixiOnAllPlatforms setting to true if you want to use Pixi on all platforms. This will allow the extension to automatically configure the ROS 2 environment using Pixi. Set the ROS2.pixiRoot setting to specify the root directory where Pixi environments are installed. This defaults to c:\\pixi_ws\\ros on Windows and not inferred on Mac or Linux. The extension will automatically detect and use the appropriate setup script based on your platform and Pixi configuration. Open a ROS 2 Workspace : Open a folder containing a ROS 2 workspace. The Robot Developer Extensions will automatically detect the ROS 2 environment and configure the workspace accordingly. Pixi Environment Detection The extension automatically detects Pixi environments by: - Checking for the presence of pixi.toml or pixi.lock files in the workspace - Looking for Pixi environment directories in the configured pixiRoot - Detecting active Pixi environments in the current shell session When Pixi is enabled, the extension will: - Source the appropriate ROS 2 setup script from the Pixi environment - Configure the Python environment to use Pixi-managed packages - Set up the build environment for ROS 2 packages using Pixi Platform-Specific Behavior Windows : Uses local_setup.bat from the Pixi ROS 2 environment Linux : Uses local_setup.bash from the Pixi ROS 2 environment macOS : Uses local_setup.bash from the Pixi ROS 2 environment Troubleshooting If you encounter issues with Pixi or the Robot Developer Extensions, consider the following: Ensure that Pixi is installed correctly and the pixi command is available in your terminal. Check the Visual Studio Code output panel for any error messages related to the Robot Developer Extensions. If you are using RoboStack, ensure that the ROS 2 packages are installed correctly and the environment is set up properly outside of the extension. Verify that the ROS2.pixiRoot setting points to the correct Pixi installation directory. For issues related to Pixi, refer to the Pixi documentation or the Pixi Discord server for community support.","title":"Pixi for ROS 2"},{"location":"pixi.html#pixi-for-ros-2","text":"Pixi by prefix.dev is a next generation package manager, which includes support for ROS 2 development environments. It provides a cross-platform way to manage ROS 2 workspaces, dependencies, and tools. Open Robotics has standardized on Pixi for Windows development.","title":"Pixi for ROS 2"},{"location":"pixi.html#robostack-open-robotics","text":"Open Robotics has partnered with RoboStack to provide a Pixi-based ROS 2 development environment. This environment is designed to work seamlessly with the Robot Developer Extensions for ROS 2, providing a consistent and easy-to-use development experience across platforms. Open Robotics provides an official distribution of core ROS Components through Open Robotics build system. This distribution is recommended for production use cases. RoboStack provides a community-driven distribution of ROS 2 packages, which includes additional packages not available in the Open Robotics distribution. This distribution is recommended for development and testing purposes.","title":"RoboStack &amp; Open Robotics"},{"location":"pixi.html#getting-started-with-pixi-ros-2-and-the-robot-developer-extensions","text":"Install Pixi : Follow the instructions on the Pixi website to install Pixi on your system. Install Visual Studio : Download and install Visual Studio . This is needed for building ROS 2 packages on Windows. Install Visual Studio Code : Download and install Visual Studio Code . Install ROS 2 through RoboStack or Open Robotics depending on your use case: For Development and Testing, follow the instructions on the RoboStack website . For Production Environments, follow the instructions on the ros.org . Install the Robot Developer Extensions (RDE) for ROS 2 : Install the Robot Developer Extensions for ROS 2 from the Visual Studio Code Marketplace or Open-Vsx.org . Configure Pixi in RDE Open the Workspace settings. Set the ROS2.usePixiOnAllPlatforms setting to true if you want to use Pixi on all platforms. This will allow the extension to automatically configure the ROS 2 environment using Pixi. Set the ROS2.pixiRoot setting to specify the root directory where Pixi environments are installed. This defaults to c:\\pixi_ws\\ros on Windows and not inferred on Mac or Linux. The extension will automatically detect and use the appropriate setup script based on your platform and Pixi configuration. Open a ROS 2 Workspace : Open a folder containing a ROS 2 workspace. The Robot Developer Extensions will automatically detect the ROS 2 environment and configure the workspace accordingly.","title":"Getting Started with Pixi, ROS 2, and the Robot Developer Extensions"},{"location":"pixi.html#pixi-environment-detection","text":"The extension automatically detects Pixi environments by: - Checking for the presence of pixi.toml or pixi.lock files in the workspace - Looking for Pixi environment directories in the configured pixiRoot - Detecting active Pixi environments in the current shell session When Pixi is enabled, the extension will: - Source the appropriate ROS 2 setup script from the Pixi environment - Configure the Python environment to use Pixi-managed packages - Set up the build environment for ROS 2 packages using Pixi","title":"Pixi Environment Detection"},{"location":"pixi.html#platform-specific-behavior","text":"Windows : Uses local_setup.bat from the Pixi ROS 2 environment Linux : Uses local_setup.bash from the Pixi ROS 2 environment macOS : Uses local_setup.bash from the Pixi ROS 2 environment","title":"Platform-Specific Behavior"},{"location":"pixi.html#troubleshooting","text":"If you encounter issues with Pixi or the Robot Developer Extensions, consider the following: Ensure that Pixi is installed correctly and the pixi command is available in your terminal. Check the Visual Studio Code output panel for any error messages related to the Robot Developer Extensions. If you are using RoboStack, ensure that the ROS 2 packages are installed correctly and the environment is set up properly outside of the extension. Verify that the ROS2.pixiRoot setting points to the correct Pixi installation directory. For issues related to Pixi, refer to the Pixi documentation or the Pixi Discord server for community support.","title":"Troubleshooting"},{"location":"test-explorer.html","text":"Test Explorer The extension integrates with VS Code's Test Explorer to discover and run ROS 2 tests directly from the editor. Supported Test Types The Test Explorer automatically discovers the following test types: Python Unit Tests - Tests using Python's unittest framework Python PyTest - Tests using the pytest framework C++ GTest - Tests using Google Test (GTest) framework Using the Test Explorer Open the Test Explorer view in VS Code (click the test flask icon in the Activity Bar) The extension automatically discovers tests in your ROS 2 workspace Tests are organized by package and test type Use the Run button to execute tests or Debug button to debug tests with breakpoints Test Discovery The extension automatically discovers tests by scanning for test files matching these patterns: Python: test_*.py C++: test_*.cpp , *_test.cpp , *Test.cpp Tests are refreshed automatically when test files are created, modified, or deleted.","title":"Test Explorer"},{"location":"test-explorer.html#test-explorer","text":"The extension integrates with VS Code's Test Explorer to discover and run ROS 2 tests directly from the editor.","title":"Test Explorer"},{"location":"test-explorer.html#supported-test-types","text":"The Test Explorer automatically discovers the following test types: Python Unit Tests - Tests using Python's unittest framework Python PyTest - Tests using the pytest framework C++ GTest - Tests using Google Test (GTest) framework","title":"Supported Test Types"},{"location":"test-explorer.html#using-the-test-explorer","text":"Open the Test Explorer view in VS Code (click the test flask icon in the Activity Bar) The extension automatically discovers tests in your ROS 2 workspace Tests are organized by package and test type Use the Run button to execute tests or Debug button to debug tests with breakpoints","title":"Using the Test Explorer"},{"location":"test-explorer.html#test-discovery","text":"The extension automatically discovers tests by scanning for test files matching these patterns: Python: test_*.py C++: test_*.cpp , *_test.cpp , *Test.cpp Tests are refreshed automatically when test files are created, modified, or deleted.","title":"Test Discovery"},{"location":"troubleshooting.html","text":"Troubleshooting the Robot Developer Extensions ROS 2 is a complex system, and issues can arise from various sources. AI and the VSCode ecosystem are fast moving targets. This document provides troubleshooting tips for self-diagnosing and common issues encountered when using the Robot Developer Extensions for ROS 2. Output Panel The VSCode output panel provides detailed logs from the Robot Developer Extensions. You can access it by going to Output: Focus on Output View or using the shortcut Ctrl+Shift+U . In the dropdwon next to the Filter edit box, select ROS 2 . Look for any error messages or warnings that might indicate what is going wrong. IF it is not clear, copy the output and paste it into a GitHub issue or Github Discussion for further assistance. Make sure you remove any sensitive information before sharing. Github Issues Bugs and feature requests are handled through Github Issues in the Repository . If you find that you are hitting the same issue as someone else, please give a :+1: or comment on an existing issue. Please provide as much details as possible, including an isolated reproduction of the issue or a pointer to an online repository. Please remove any sensitive information before sharing. Discussions Github Discussions are provided for community driven general guidance, walkthroughs, or asynchronous support.","title":"Troubleshooting"},{"location":"troubleshooting.html#troubleshooting-the-robot-developer-extensions","text":"ROS 2 is a complex system, and issues can arise from various sources. AI and the VSCode ecosystem are fast moving targets. This document provides troubleshooting tips for self-diagnosing and common issues encountered when using the Robot Developer Extensions for ROS 2.","title":"Troubleshooting the Robot Developer Extensions"},{"location":"troubleshooting.html#output-panel","text":"The VSCode output panel provides detailed logs from the Robot Developer Extensions. You can access it by going to Output: Focus on Output View or using the shortcut Ctrl+Shift+U . In the dropdwon next to the Filter edit box, select ROS 2 . Look for any error messages or warnings that might indicate what is going wrong. IF it is not clear, copy the output and paste it into a GitHub issue or Github Discussion for further assistance. Make sure you remove any sensitive information before sharing.","title":"Output Panel"},{"location":"troubleshooting.html#github-issues","text":"Bugs and feature requests are handled through Github Issues in the Repository . If you find that you are hitting the same issue as someone else, please give a :+1: or comment on an existing issue. Please provide as much details as possible, including an isolated reproduction of the issue or a pointer to an online repository. Please remove any sensitive information before sharing.","title":"Github Issues"},{"location":"troubleshooting.html#discussions","text":"Github Discussions are provided for community driven general guidance, walkthroughs, or asynchronous support.","title":"Discussions"},{"location":"tutorials.html","text":"Tutorials and Walkthroughs Name Description Attaching to a running ROS Node Learn how to attach VS Code to a running ROS node Debugging all ROS Nodes in a launch file Learn how to set up VS Code to debug the nodes in a ROS Launch file ROSCON 2019 ROS Extension Talk Video Walkthrough of VS Code from ROSCon 2019 Deep Dive - Episode 0 About the VS Code ROS extension @ a Polyhobbyist Deep Dive - Episode 1 Installing on Windows & WSL @ a Polyhobbyist Deep Dive - Episode 2 Installing on Linux @ a Polyhobbyist Deep Dive - Episode 3 General Usage with ROS1 @ a Polyhobbyist Deep Dive - Episode 4 General Usage with ROS2 @ a Polyhobbyist Deep Dive - Episode 5 Debugging Python @ a Polyhobbyist Deep Dive - Episode 6 Debugging C++ @ a Polyhobbyist Deep Dive - Episode 7 Using with SSH @ a Polyhobbyist Deep Dive - Episode 8 Using with with Containers @ a Polyhobbyist","title":"Tutorials"},{"location":"tutorials.html#tutorials-and-walkthroughs","text":"Name Description Attaching to a running ROS Node Learn how to attach VS Code to a running ROS node Debugging all ROS Nodes in a launch file Learn how to set up VS Code to debug the nodes in a ROS Launch file ROSCON 2019 ROS Extension Talk Video Walkthrough of VS Code from ROSCon 2019 Deep Dive - Episode 0 About the VS Code ROS extension @ a Polyhobbyist Deep Dive - Episode 1 Installing on Windows & WSL @ a Polyhobbyist Deep Dive - Episode 2 Installing on Linux @ a Polyhobbyist Deep Dive - Episode 3 General Usage with ROS1 @ a Polyhobbyist Deep Dive - Episode 4 General Usage with ROS2 @ a Polyhobbyist Deep Dive - Episode 5 Debugging Python @ a Polyhobbyist Deep Dive - Episode 6 Debugging C++ @ a Polyhobbyist Deep Dive - Episode 7 Using with SSH @ a Polyhobbyist Deep Dive - Episode 8 Using with with Containers @ a Polyhobbyist","title":"Tutorials and Walkthroughs"},{"location":"usage.html","text":"Commands You can access the following commands from the Visual Studio Code command pallet , typically accessed by pressing ctrl + shift + p and typing the command name you'd like to use from the table below. Name Description ROS2: Create Terminal Create a terminal with the ROS environment. ROS2: Show Status Open a detail view showing ROS core runtime status. ROS2: Start Start ROS1 core or ROS2 Daemon. ROS2: Stop Terminate ROS core or ROS2 Daemon. ROS2: Update C++ Properties Update the C++ IntelliSense configuration to include ROS and your ROS components. See IntelliSense for more details. ROS2: Update Python Path Update the Python IntelliSense configuration to include ROS. See IntelliSense for more details. ROS2: Preview URDF Preview URDF and Xacro files. The display will update after the root URDF changes are saved. ROS2: Install ROS Dependencies for this workspace using rosdep Shortcut for rosdep install --from-paths src --ignore-src -r -y . IntelliSense Features The extension provides rich IntelliSense support for ROS message files ( .msg , .srv , .action ). For detailed information about hover tooltips, go-to-definition, and other IntelliSense features, see the IntelliSense documentation .","title":"Usage"},{"location":"usage.html#commands","text":"You can access the following commands from the Visual Studio Code command pallet , typically accessed by pressing ctrl + shift + p and typing the command name you'd like to use from the table below. Name Description ROS2: Create Terminal Create a terminal with the ROS environment. ROS2: Show Status Open a detail view showing ROS core runtime status. ROS2: Start Start ROS1 core or ROS2 Daemon. ROS2: Stop Terminate ROS core or ROS2 Daemon. ROS2: Update C++ Properties Update the C++ IntelliSense configuration to include ROS and your ROS components. See IntelliSense for more details. ROS2: Update Python Path Update the Python IntelliSense configuration to include ROS. See IntelliSense for more details. ROS2: Preview URDF Preview URDF and Xacro files. The display will update after the root URDF changes are saved. ROS2: Install ROS Dependencies for this workspace using rosdep Shortcut for rosdep install --from-paths src --ignore-src -r -y .","title":"Commands"},{"location":"usage.html#intellisense-features","text":"The extension provides rich IntelliSense support for ROS message files ( .msg , .srv , .action ). For detailed information about hover tooltips, go-to-definition, and other IntelliSense features, see the IntelliSense documentation .","title":"IntelliSense Features"}]}